\hypertarget{classomexmeta_1_1Predicate}{}\doxysection{omexmeta\+::Predicate Class Reference}
\label{classomexmeta_1_1Predicate}\index{omexmeta::Predicate@{omexmeta::Predicate}}


{\ttfamily \#include $<$Predicate.\+h$>$}

Inheritance diagram for omexmeta\+::Predicate\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=0.978166cm]{classomexmeta_1_1Predicate}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classomexmeta_1_1Predicate_ad5a91eb29204202d2f18816d09677622}{Predicate}} (const std\+::string \&\mbox{\hyperlink{classomexmeta_1_1Predicate_afc79b0cc43eb11e4bc2fe0b305e551bc}{namespace\+\_\+}}, std\+::string term, std\+::string prefix)
\begin{DoxyCompactList}\small\item\em construct a \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} from a namespace, term and prefix portion of a predicate \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a28edc476ba8cd53a51c6a1d60a40f133}\label{classomexmeta_1_1Predicate_a28edc476ba8cd53a51c6a1d60a40f133}} 
{\bfseries Predicate} (\mbox{\hyperlink{classredland_1_1LibrdfNode}{Librdf\+Node}} node)
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a5db1e6150f8cfd7605e82996e2aebb50}\label{classomexmeta_1_1Predicate_a5db1e6150f8cfd7605e82996e2aebb50}} 
bool {\bfseries operator==} (const \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} \&rhs) const
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a7bf4b8769eb9801eb26cc976723b56f2}\label{classomexmeta_1_1Predicate_a7bf4b8769eb9801eb26cc976723b56f2}} 
bool {\bfseries operator!=} (const \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} \&rhs) const
\item 
std\+::string \mbox{\hyperlink{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}{str}} ()
\begin{DoxyCompactList}\small\item\em get the predicate as a full string \end{DoxyCompactList}\item 
const std\+::vector$<$ std\+::string $>$ \& \mbox{\hyperlink{classomexmeta_1_1Predicate_aee19b8fc8b21f8e5ffd5b64691e1e530}{get\+Valid\+Terms}} () const
\begin{DoxyCompactList}\small\item\em stores the valid terms that are allowed in a particular predicate subclass \end{DoxyCompactList}\item 
const std\+::string \& \mbox{\hyperlink{classomexmeta_1_1Predicate_add4ab1cd86f83de3512279bbfdad947c}{get\+Namespace}} () const
\begin{DoxyCompactList}\small\item\em getter for the namespace portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} \end{DoxyCompactList}\item 
const std\+::string \& \mbox{\hyperlink{classomexmeta_1_1Predicate_a54a15176bd697d37d00573bf86954630}{get\+Term}} () const
\begin{DoxyCompactList}\small\item\em getter for term portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} \end{DoxyCompactList}\item 
const std\+::string \& \mbox{\hyperlink{classomexmeta_1_1Predicate_a0147e977f71604db05763815ae6b553f}{get\+Prefix}} () const
\begin{DoxyCompactList}\small\item\em getter for the prefix portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} \end{DoxyCompactList}\item 
const std\+::string \& \mbox{\hyperlink{classomexmeta_1_1Predicate_a27fa7d62ad9a5182f3dd642bc61c8d9f}{get\+Uri}} () const
\begin{DoxyCompactList}\small\item\em getter for uri \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classomexmeta_1_1Predicate_a718a37ff90ac0f2d7cc129e8351a2c7b}{free\+Node}} ()
\begin{DoxyCompactList}\small\item\em release resources associated with this \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classomexmeta_1_1Predicate_a176c7f9d009100931376ee6a87779e3c}{set\+Node}} (\mbox{\hyperlink{classredland_1_1LibrdfNode}{Librdf\+Node}} \&node)
\begin{DoxyCompactList}\small\item\em replace the current librdf\+\_\+node assicated with this \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} with node \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_ae2adc312e293aabfdbbffbb44018665b}\label{classomexmeta_1_1Predicate_ae2adc312e293aabfdbbffbb44018665b}} 
\mbox{\hyperlink{classredland_1_1LibrdfNode}{Librdf\+Node}} {\bfseries get\+Node} ()
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::unordered\+\_\+map$<$ std\+::string, std\+::string $>$ \mbox{\hyperlink{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}{namespace\+Map}} ()
\begin{DoxyCompactList}\small\item\em get a map namespaces and prefixes \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classomexmeta_1_1Predicate_a1e7e59b8a48c9f89eeec73f3bbaea19c}{verify}} (std\+::vector$<$ std\+::string $>$ valid\+\_\+terms, const std\+::string \&term)
\begin{DoxyCompactList}\small\item\em Static method for checking validity of term against valid\+\_\+terms. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classomexmeta_1_1Predicate_a8381c8b0c7bbaa27de29608cbff08bf5}{namespace\+Known}} (const std\+::string \&ns)
\begin{DoxyCompactList}\small\item\em check if we have \char`\"{}know\char`\"{} a namespace. Known namespaces are returned by \mbox{\hyperlink{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}{Predicate\+::namespace\+Map()}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_ac872644a6609cc8c11459237b3b781a6}\label{classomexmeta_1_1Predicate_ac872644a6609cc8c11459237b3b781a6}} 
static void \mbox{\hyperlink{classomexmeta_1_1Predicate_ac872644a6609cc8c11459237b3b781a6}{add\+Seen\+Namespace\+To\+Serializer}} (\mbox{\hyperlink{classredland_1_1LibrdfSerializer}{Librdf\+Serializer}} serializer, \mbox{\hyperlink{classredland_1_1LibrdfNode}{Librdf\+Node}} predicate)
\begin{DoxyCompactList}\small\item\em utility for checking whether the uri in @parameter predicate has a namespace that we already know. If found, the namespace is added to @parameter serializer \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_afc79b0cc43eb11e4bc2fe0b305e551bc}\label{classomexmeta_1_1Predicate_afc79b0cc43eb11e4bc2fe0b305e551bc}} 
std\+::string \mbox{\hyperlink{classomexmeta_1_1Predicate_afc79b0cc43eb11e4bc2fe0b305e551bc}{namespace\+\_\+}}
\begin{DoxyCompactList}\small\item\em make a shared pointer from this \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_ab626a5fd9fa8f302767d4ca544a9eff2}\label{classomexmeta_1_1Predicate_ab626a5fd9fa8f302767d4ca544a9eff2}} 
std\+::string {\bfseries term\+\_\+}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a5dfbbc85f7bdc5a3e4da72913f6ce306}\label{classomexmeta_1_1Predicate_a5dfbbc85f7bdc5a3e4da72913f6ce306}} 
std\+::string {\bfseries prefix\+\_\+}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a4fe359b93a9dea9b60f7bc28c1aa913b}\label{classomexmeta_1_1Predicate_a4fe359b93a9dea9b60f7bc28c1aa913b}} 
std\+::string {\bfseries uri\+\_\+}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a14ae7768fbd3aaf444bcde8650910c0b}\label{classomexmeta_1_1Predicate_a14ae7768fbd3aaf444bcde8650910c0b}} 
std\+::vector$<$ std\+::string $>$ {\bfseries valid\+\_\+terms\+\_\+} \{\char`\"{}All\char`\"{}\}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a1c062fe0337919ecbffba1f567b77048}\label{classomexmeta_1_1Predicate_a1c062fe0337919ecbffba1f567b77048}} 
\mbox{\hyperlink{classredland_1_1LibrdfNode}{Librdf\+Node}} {\bfseries node\+\_\+}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The predicate class creates and stores a URI node. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_ad5a91eb29204202d2f18816d09677622}\label{classomexmeta_1_1Predicate_ad5a91eb29204202d2f18816d09677622}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!Predicate@{Predicate}}
\index{Predicate@{Predicate}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{Predicate()}{Predicate()}}
{\footnotesize\ttfamily omexmeta\+::\+Predicate\+::\+Predicate (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{namespace\+\_\+,  }\item[{std\+::string}]{term,  }\item[{std\+::string}]{prefix }\end{DoxyParamCaption})}



construct a \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} from a namespace, term and prefix portion of a predicate 


\begin{DoxyParams}{Parameters}
{\em namespace\+\_\+} & the namespace portion of a predicate. i.\+e. \href{http://biomodels.net/biology-qualifiers/}{\texttt{ http\+://biomodels.\+net/biology-\/qualifiers/}} \\
\hline
{\em term} & the last portion of the predicate, i.\+e. is \\
\hline
{\em prefix} & the prefix that can be used instead of the full namespace, i.\+e. bqbiol\\
\hline
\end{DoxyParams}
\href{http://biomodels.net/biology-qualifiers/is}{\texttt{ http\+://biomodels.\+net/biology-\/qualifiers/is}} -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$\vert$-- $\vert$ $\vert$ namespace term

is equivalent to

bqbiol\+:is -\/-\/-\/---$\vert$-- $\vert$ $\vert$ prefix term 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a718a37ff90ac0f2d7cc129e8351a2c7b}\label{classomexmeta_1_1Predicate_a718a37ff90ac0f2d7cc129e8351a2c7b}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!freeNode@{freeNode}}
\index{freeNode@{freeNode}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{freeNode()}{freeNode()}}
{\footnotesize\ttfamily void omexmeta\+::\+Predicate\+::free\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



release resources associated with this \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}}. 

\mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} objects contain a librdf\+\_\+node pointer which needs to be freed by the caller. If a \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} is passed to a \mbox{\hyperlink{classomexmeta_1_1Triple}{Triple}} object (which most of the time is it), responsibility for deleting the contained librdf\+\_\+node is transferred to the \mbox{\hyperlink{classomexmeta_1_1Triple}{Triple}} object, which automatically clears up resources. If not, then it is the callers responsibility to call this method when they are done with \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} instances. \mbox{\Hypertarget{classomexmeta_1_1Predicate_add4ab1cd86f83de3512279bbfdad947c}\label{classomexmeta_1_1Predicate_add4ab1cd86f83de3512279bbfdad947c}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!getNamespace@{getNamespace}}
\index{getNamespace@{getNamespace}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{getNamespace()}{getNamespace()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Namespace (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for the namespace portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} 

\begin{DoxyReturn}{Returns}
the string representing the namespace of the current \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a0147e977f71604db05763815ae6b553f}\label{classomexmeta_1_1Predicate_a0147e977f71604db05763815ae6b553f}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!getPrefix@{getPrefix}}
\index{getPrefix@{getPrefix}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{getPrefix()}{getPrefix()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Prefix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for the prefix portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} 

\begin{DoxyReturn}{Returns}
the string representing the prefix portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a54a15176bd697d37d00573bf86954630}\label{classomexmeta_1_1Predicate_a54a15176bd697d37d00573bf86954630}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!getTerm@{getTerm}}
\index{getTerm@{getTerm}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{getTerm()}{getTerm()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Term (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for term portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} 

\begin{DoxyReturn}{Returns}
the string representing the term portion of the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a27fa7d62ad9a5182f3dd642bc61c8d9f}\label{classomexmeta_1_1Predicate_a27fa7d62ad9a5182f3dd642bc61c8d9f}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!getUri@{getUri}}
\index{getUri@{getUri}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{getUri()}{getUri()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Uri (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for uri 

For developers. Consider removing since \mbox{\hyperlink{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}{str()}} method does the same thing \mbox{\Hypertarget{classomexmeta_1_1Predicate_aee19b8fc8b21f8e5ffd5b64691e1e530}\label{classomexmeta_1_1Predicate_aee19b8fc8b21f8e5ffd5b64691e1e530}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!getValidTerms@{getValidTerms}}
\index{getValidTerms@{getValidTerms}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{getValidTerms()}{getValidTerms()}}
{\footnotesize\ttfamily const std\+::vector$<$ std\+::string $>$ \& omexmeta\+::\+Predicate\+::get\+Valid\+Terms (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



stores the valid terms that are allowed in a particular predicate subclass 

\begin{DoxyReturn}{Returns}
a vector of strings
\end{DoxyReturn}
Subclasses override this method so they return a complete list of valid terms for their own class \mbox{\Hypertarget{classomexmeta_1_1Predicate_a8381c8b0c7bbaa27de29608cbff08bf5}\label{classomexmeta_1_1Predicate_a8381c8b0c7bbaa27de29608cbff08bf5}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!namespaceKnown@{namespaceKnown}}
\index{namespaceKnown@{namespaceKnown}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{namespaceKnown()}{namespaceKnown()}}
{\footnotesize\ttfamily bool omexmeta\+::\+Predicate\+::namespace\+Known (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{ns }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



check if we have \char`\"{}know\char`\"{} a namespace. Known namespaces are returned by \mbox{\hyperlink{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}{Predicate\+::namespace\+Map()}}. 


\begin{DoxyParams}{Parameters}
{\em ns} & the namespace to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if we have seen the namespace ns before 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}\label{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!namespaceMap@{namespaceMap}}
\index{namespaceMap@{namespaceMap}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{namespaceMap()}{namespaceMap()}}
{\footnotesize\ttfamily std\+::unordered\+\_\+map$<$ std\+::string, std\+::string $>$ omexmeta\+::\+Predicate\+::namespace\+Map (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



get a map namespaces and prefixes 

\begin{DoxyReturn}{Returns}
a unordered\+\_\+map with namespaces as keys and prefixes as values 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a176c7f9d009100931376ee6a87779e3c}\label{classomexmeta_1_1Predicate_a176c7f9d009100931376ee6a87779e3c}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!setNode@{setNode}}
\index{setNode@{setNode}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{setNode()}{setNode()}}
{\footnotesize\ttfamily void omexmeta\+::\+Predicate\+::set\+Node (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classredland_1_1LibrdfNode}{Librdf\+Node}} \&}]{node }\end{DoxyParamCaption})}



replace the current librdf\+\_\+node assicated with this \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} with node 


\begin{DoxyParams}{Parameters}
{\em node} & the new librdf\+\_\+node pointer to use in the \mbox{\hyperlink{classomexmeta_1_1Predicate}{Predicate}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}\label{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!str@{str}}
\index{str@{str}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{str()}{str()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Predicate\+::str (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



get the predicate as a full string 

\begin{DoxyReturn}{Returns}
a string representing the predicate 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a1e7e59b8a48c9f89eeec73f3bbaea19c}\label{classomexmeta_1_1Predicate_a1e7e59b8a48c9f89eeec73f3bbaea19c}} 
\index{omexmeta::Predicate@{omexmeta::Predicate}!verify@{verify}}
\index{verify@{verify}!omexmeta::Predicate@{omexmeta::Predicate}}
\doxysubsubsection{\texorpdfstring{verify()}{verify()}}
{\footnotesize\ttfamily void omexmeta\+::\+Predicate\+::verify (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::string $>$}]{valid\+\_\+terms,  }\item[{const std\+::string \&}]{term }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Static method for checking validity of term against valid\+\_\+terms. 


\begin{DoxyParams}{Parameters}
{\em term} & the term to validate \\
\hline
{\em valid\+\_\+terms} & the set of terms to validate term against\\
\hline
\end{DoxyParams}
Throws an error when term is not in valid\+\_\+terms. Used by subclasses to verify user input. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/omexmeta/include/omexmeta/Predicate.\+h\item 
src/omexmeta/Predicate.\+cpp\end{DoxyCompactItemize}
