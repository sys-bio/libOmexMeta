\hypertarget{classomexmeta_1_1OmexMetaUtils}{}\doxysection{omexmeta\+::Omex\+Meta\+Utils Class Reference}
\label{classomexmeta_1_1OmexMetaUtils}\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_ab72b362607e6bbdd0025eefa574cd073}{exists}} (const std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em return true when filename is a file that exists on system \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a9c445a8e0cc6589b25d6fa630686c171}{remove\+File}} (const std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em remove file called \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a8e629136cb2685ed839ea3a0e88094e6}{remove\+If\+Exists}} (const std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em remove a file, checking for its existance first \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a046b603d6308242b70b55de6cb72325c}{download}} (const std\+::string \&url, std\+::string filename)
\begin{DoxyCompactList}\small\item\em download a file from \end{DoxyCompactList}\item 
static std\+::vector$<$ std\+::string $>$ \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_aac769ce6e901f32820cd7dc3fef989fa}{split\+String\+By}} (const std\+::string \&str, char delimiter)
\begin{DoxyCompactList}\small\item\em split a string into a vector of strings by \end{DoxyCompactList}\item 
static std\+::string \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_ad47205ad2bcb06742ce96c5aaca8d493}{generate\+Unique\+Metaid}} (\mbox{\hyperlink{classredland_1_1LibrdfModel}{Librdf\+Model}} \&model, const std\+::string \&metaid\+\_\+base, const std\+::vector$<$ std\+::string $>$ \&exclusions)
\begin{DoxyCompactList}\small\item\em utility for generating unique metaids given an xml document \end{DoxyCompactList}\item 
static std\+::string \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a6694715cf3f5dccd33d416ecc84ff375}{prepare\+Base\+Uri}} (std\+::string str, bool absolute\+\_\+path=false)
\begin{DoxyCompactList}\small\item\em process a string intended to be a base uri. \end{DoxyCompactList}\item 
static std\+::string \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a0956bde073b212596d8e4b2ffc983e47}{get\+Namespace\+From\+Uri}} (const std\+::string \&uri)
\begin{DoxyCompactList}\small\item\em takes a uri as std\+::string and returns the string with the last section removed; \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_af663724f2efb0324a64c6a57e8491c13}{is\+Formatted\+Uri}} (std\+::string uri)
\begin{DoxyCompactList}\small\item\em helper function that returns true when uri starts with either {\ttfamily \href{https://}{\texttt{ https\+://}}} {\ttfamily \href{http://}{\texttt{ http\+://}}} or {\ttfamily \href{file://}{\texttt{ file\+://}}} \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a9c2b712b85f74fff9740477660f7b371}{ends\+With}} (std\+::string const \&full\+\_\+string, std\+::string const \&ending)
\begin{DoxyCompactList}\small\item\em test to see whether a string ends with another string \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a4ec81c80bf33d232331ea9ef0b94da61}\label{classomexmeta_1_1OmexMetaUtils_a4ec81c80bf33d232331ea9ef0b94da61}} 
static bool \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a4ec81c80bf33d232331ea9ef0b94da61}{assert\+Regex\+Match\+Split\+By\+New\+Line}} (const std\+::string \&expected\+\_\+string, const std\+::string \&actual\+\_\+string)
\begin{DoxyCompactList}\small\item\em test that expected\+\_\+string matches actual\+\_\+string when split by new lines and matched as a regex \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a6ddc16d56f238ef7ff3c8ab355163ef7}\label{classomexmeta_1_1OmexMetaUtils_a6ddc16d56f238ef7ff3c8ab355163ef7}} 
static bool {\bfseries assert\+Match\+By\+New\+Line} (const std\+::string \&expected\+\_\+string, const std\+::string \&actual\+\_\+string)
\item 
static std\+::vector$<$ std\+::string $>$ \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a744a0575136f1cc60b76a6560a5595e9}{configure\+Prefix\+Strings}} (std\+::string repository\+\_\+name, std\+::string omex\+\_\+name, std\+::string model\+\_\+name)
\begin{DoxyCompactList}\small\item\em configures the \char`\"{}\+OMEXlib\char`\"{}, \char`\"{}my\+OMEX\char`\"{} and \char`\"{}local\char`\"{} prefixes @ param omex\+\_\+name the name of the omex container your model is in \end{DoxyCompactList}\item 
static std\+::string \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_ae645af49ce57dac8bd0e0eba9e39a6c0}{concat\+Meta\+Id\+And\+Uri}} (std\+::string metaid, std\+::string uri)
\begin{DoxyCompactList}\small\item\em concatonate metaid and uri strings \end{DoxyCompactList}\item 
static std\+::string \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_aca2230ca99338b9dc0fc7d296b0c553b}{string\+Replace}} (std\+::string str, const std\+::string \&string\+\_\+to\+\_\+replace, const std\+::string \&replacement)
\begin{DoxyCompactList}\small\item\em replace a part of a string \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a66d58e0ebcbee1857b23ead70c87de7f}{starts\+With}} (const std\+::string \&full\+\_\+string, const std\+::string \&start)
\begin{DoxyCompactList}\small\item\em returns true when \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a6f8e406b8798bd2f1f0ae0d1bd07ed2b}{string\+In\+Vector}} (std\+::vector$<$ std\+::string $>$ vec, const std\+::string \&string)
\begin{DoxyCompactList}\small\item\em returns true when \end{DoxyCompactList}\item 
static xml\+Doc $\ast$ \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a718710d8ba7fc7598bd73a5456b3d903}{parse\+Xml\+Document}} (const std\+::string \&xml\+\_\+string)
\begin{DoxyCompactList}\small\item\em read an xml document using libxml2. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a29cc8222c809162eadbc424a0687cbf3}\label{classomexmeta_1_1OmexMetaUtils_a29cc8222c809162eadbc424a0687cbf3}} 
static std\+::string {\bfseries get\+Xml\+Node\+Property} (xml\+Node $\ast$node, const std\+::string \&property)
\item 
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a1dbcd874b2b72531e7f4f9e82524d8e8}\label{classomexmeta_1_1OmexMetaUtils_a1dbcd874b2b72531e7f4f9e82524d8e8}} 
static xml\+Node $\ast$ {\bfseries get\+Child\+Element\+Called} (xml\+Node $\ast$node, const std\+::string \&name)
\item 
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a4d6f7d2140c42435be9339edf975b949}\label{classomexmeta_1_1OmexMetaUtils_a4d6f7d2140c42435be9339edf975b949}} 
static std\+::vector$<$ xml\+Node $\ast$ $>$ {\bfseries get\+All\+Child\+Elements} (xml\+Node $\ast$node)
\item 
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a96e93667c8799b9569cb30fc102b129b}\label{classomexmeta_1_1OmexMetaUtils_a96e93667c8799b9569cb30fc102b129b}} 
static bool {\bfseries is\+Sub\+String} (const std\+::string \&full\+\_\+string, const std\+::string \&substring)
\item 
static std\+::string \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a68c571d229b00a082f3b5c9ad2f10dbc}{read\+From\+File}} (const std\+::string \&file)
\begin{DoxyCompactList}\small\item\em read \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\static bool \mbox{\hyperlink{classomexmeta_1_1OmexMetaUtils_a2493ba8fb1c95d05faa9f206be566ba2}{is\+String\+Empty}} (T \&cls, const std\+::string \&s)
\begin{DoxyCompactList}\small\item\em return true when \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_ae645af49ce57dac8bd0e0eba9e39a6c0}\label{classomexmeta_1_1OmexMetaUtils_ae645af49ce57dac8bd0e0eba9e39a6c0}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!concatMetaIdAndUri@{concatMetaIdAndUri}}
\index{concatMetaIdAndUri@{concatMetaIdAndUri}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{concatMetaIdAndUri()}{concatMetaIdAndUri()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Omex\+Meta\+Utils\+::concat\+Meta\+Id\+And\+Uri (\begin{DoxyParamCaption}\item[{std\+::string}]{metaid,  }\item[{std\+::string}]{uri }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



concatonate metaid and uri strings 


\begin{DoxyParams}{Parameters}
{\em metaid} & string. Like \char`\"{}\#metaid\char`\"{} or \char`\"{}metaid\char`\"{} \\
\hline
{\em uri} & string. Like \char`\"{}https\+://omex-\/library/jeff2019.\+omex/mymodel.\+xml\char`\"{} or \char`\"{}https\+://omex-\/library/jeff2019.\+omex/mymodel.\+rdf\char`\"{}\\
\hline
\end{DoxyParams}
Sometimes a uri has a trailing \char`\"{}\#\char`\"{} and somtimes a metaid has a leading \char`\"{}\#\char`\"{}. \mbox{\hyperlink{classThis}{This}} method concatonates whilst accounting for permutations of \char`\"{}\#\char`\"{} \mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a744a0575136f1cc60b76a6560a5595e9}\label{classomexmeta_1_1OmexMetaUtils_a744a0575136f1cc60b76a6560a5595e9}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!configurePrefixStrings@{configurePrefixStrings}}
\index{configurePrefixStrings@{configurePrefixStrings}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{configurePrefixStrings()}{configurePrefixStrings()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::string $>$ omexmeta\+::\+Omex\+Meta\+Utils\+::configure\+Prefix\+Strings (\begin{DoxyParamCaption}\item[{std\+::string}]{repository\+\_\+name,  }\item[{std\+::string}]{omex\+\_\+name,  }\item[{std\+::string}]{model\+\_\+name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



configures the \char`\"{}\+OMEXlib\char`\"{}, \char`\"{}my\+OMEX\char`\"{} and \char`\"{}local\char`\"{} prefixes @ param omex\+\_\+name the name of the omex container your model is in 


\begin{DoxyParams}{Parameters}
{\em model\+\_\+name} & the name of the model your are annotating. Extension should be included or it will be given the \char`\"{}.\+xml\char`\"{} suffix. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a046b603d6308242b70b55de6cb72325c}\label{classomexmeta_1_1OmexMetaUtils_a046b603d6308242b70b55de6cb72325c}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!download@{download}}
\index{download@{download}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{download()}{download()}}
{\footnotesize\ttfamily void omexmeta\+::\+Omex\+Meta\+Utils\+::download (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{url,  }\item[{std\+::string}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



download a file from 


\begin{DoxyParams}{Parameters}
{\em url} & to\\
\hline
{\em filename} & \begin{DoxyVerb}wrapper around the CurlGet function, as the utils
\end{DoxyVerb}
 class seems like a good place for the download features. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a9c2b712b85f74fff9740477660f7b371}\label{classomexmeta_1_1OmexMetaUtils_a9c2b712b85f74fff9740477660f7b371}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!endsWith@{endsWith}}
\index{endsWith@{endsWith}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{endsWith()}{endsWith()}}
{\footnotesize\ttfamily bool omexmeta\+::\+Omex\+Meta\+Utils\+::ends\+With (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{full\+\_\+string,  }\item[{std\+::string const \&}]{ending }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



test to see whether a string ends with another string 


\begin{DoxyParams}{Parameters}
{\em full\+String} & the string to test \\
\hline
{\em ending} & the ending to test for \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_ab72b362607e6bbdd0025eefa574cd073}\label{classomexmeta_1_1OmexMetaUtils_ab72b362607e6bbdd0025eefa574cd073}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!exists@{exists}}
\index{exists@{exists}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{exists()}{exists()}}
{\footnotesize\ttfamily bool omexmeta\+::\+Omex\+Meta\+Utils\+::exists (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



return true when filename is a file that exists on system 


\begin{DoxyParams}{Parameters}
{\em filename} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_ad47205ad2bcb06742ce96c5aaca8d493}\label{classomexmeta_1_1OmexMetaUtils_ad47205ad2bcb06742ce96c5aaca8d493}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!generateUniqueMetaid@{generateUniqueMetaid}}
\index{generateUniqueMetaid@{generateUniqueMetaid}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{generateUniqueMetaid()}{generateUniqueMetaid()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Omex\+Meta\+Utils\+::generate\+Unique\+Metaid (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classredland_1_1LibrdfModel}{Librdf\+Model}} \&}]{model,  }\item[{const std\+::string \&}]{metaid\+\_\+base,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{exclusions }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



utility for generating unique metaids given an xml document 

model a librdf\+\_\+model$\ast$ pointer

a string that will be used for the ID. There will be 4 digits, though this can be changed.

exclusions. Mostly needed internally for dealing with metaids that already exist. \mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a0956bde073b212596d8e4b2ffc983e47}\label{classomexmeta_1_1OmexMetaUtils_a0956bde073b212596d8e4b2ffc983e47}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!getNamespaceFromUri@{getNamespaceFromUri}}
\index{getNamespaceFromUri@{getNamespaceFromUri}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{getNamespaceFromUri()}{getNamespaceFromUri()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Omex\+Meta\+Utils\+::get\+Namespace\+From\+Uri (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{uri }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



takes a uri as std\+::string and returns the string with the last section removed; 

Example\+: www.\+uri.\+com/identifer/\+PD12345 will turn into www.\+uri.\+com/identifier/ \mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_af663724f2efb0324a64c6a57e8491c13}\label{classomexmeta_1_1OmexMetaUtils_af663724f2efb0324a64c6a57e8491c13}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!isFormattedUri@{isFormattedUri}}
\index{isFormattedUri@{isFormattedUri}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{isFormattedUri()}{isFormattedUri()}}
{\footnotesize\ttfamily bool omexmeta\+::\+Omex\+Meta\+Utils\+::is\+Formatted\+Uri (\begin{DoxyParamCaption}\item[{std\+::string}]{uri }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



helper function that returns true when uri starts with either {\ttfamily \href{https://}{\texttt{ https\+://}}} {\ttfamily \href{http://}{\texttt{ http\+://}}} or {\ttfamily \href{file://}{\texttt{ file\+://}}} 


\begin{DoxyParams}{Parameters}
{\em uri} & the uri to test. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a2493ba8fb1c95d05faa9f206be566ba2}\label{classomexmeta_1_1OmexMetaUtils_a2493ba8fb1c95d05faa9f206be566ba2}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!isStringEmpty@{isStringEmpty}}
\index{isStringEmpty@{isStringEmpty}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{isStringEmpty()}{isStringEmpty()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
static bool omexmeta\+::\+Omex\+Meta\+Utils\+::is\+String\+Empty (\begin{DoxyParamCaption}\item[{T \&}]{cls,  }\item[{const std\+::string \&}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



return true when 


\begin{DoxyParams}{Parameters}
{\em s} & is empty OR equal to model or local uri\textquotesingle{}s \\
\hline
{\em T} & must implement the methods get\+Model\+Uri and get\+Local\+Uri \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a718710d8ba7fc7598bd73a5456b3d903}\label{classomexmeta_1_1OmexMetaUtils_a718710d8ba7fc7598bd73a5456b3d903}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!parseXmlDocument@{parseXmlDocument}}
\index{parseXmlDocument@{parseXmlDocument}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{parseXmlDocument()}{parseXmlDocument()}}
{\footnotesize\ttfamily xml\+Doc $\ast$ omexmeta\+::\+Omex\+Meta\+Utils\+::parse\+Xml\+Document (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{xml\+\_\+string }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



read an xml document using libxml2. 

\begin{DoxyReturn}{Returns}
xml\+Doc$\ast$. Caller is responsible for calling xml\+Free\+Doc(doc). 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a6694715cf3f5dccd33d416ecc84ff375}\label{classomexmeta_1_1OmexMetaUtils_a6694715cf3f5dccd33d416ecc84ff375}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!prepareBaseUri@{prepareBaseUri}}
\index{prepareBaseUri@{prepareBaseUri}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{prepareBaseUri()}{prepareBaseUri()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Omex\+Meta\+Utils\+::prepare\+Base\+Uri (\begin{DoxyParamCaption}\item[{std\+::string}]{str,  }\item[{bool}]{absolute\+\_\+path = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



process a string intended to be a base uri. 


\begin{DoxyParams}{Parameters}
{\em str} & The string that will become a base uri \\
\hline
{\em absolute\+\_\+path} & automatically make str an absolute path to the current working directory.\\
\hline
\end{DoxyParams}
Base uri\textquotesingle{}s are important in redland libraries. If they do not begin with {\ttfamily \href{file://}{\texttt{ file\+://}}} {\ttfamily http} or {\ttfamily https}, sparql querying will break down. \mbox{\hyperlink{classThis}{This}} is a helper function to ensure the base uri is properly formatted. \mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a68c571d229b00a082f3b5c9ad2f10dbc}\label{classomexmeta_1_1OmexMetaUtils_a68c571d229b00a082f3b5c9ad2f10dbc}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!readFromFile@{readFromFile}}
\index{readFromFile@{readFromFile}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{readFromFile()}{readFromFile()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Omex\+Meta\+Utils\+::read\+From\+File (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{file }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



read 


\begin{DoxyParams}{Parameters}
{\em file} & into std\+::string \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a9c445a8e0cc6589b25d6fa630686c171}\label{classomexmeta_1_1OmexMetaUtils_a9c445a8e0cc6589b25d6fa630686c171}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!removeFile@{removeFile}}
\index{removeFile@{removeFile}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{removeFile()}{removeFile()}}
{\footnotesize\ttfamily int omexmeta\+::\+Omex\+Meta\+Utils\+::remove\+File (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



remove file called 


\begin{DoxyParams}{Parameters}
{\em filename} & \\
\hline
{\em filename} & to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 0 when successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a8e629136cb2685ed839ea3a0e88094e6}\label{classomexmeta_1_1OmexMetaUtils_a8e629136cb2685ed839ea3a0e88094e6}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!removeIfExists@{removeIfExists}}
\index{removeIfExists@{removeIfExists}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{removeIfExists()}{removeIfExists()}}
{\footnotesize\ttfamily void omexmeta\+::\+Omex\+Meta\+Utils\+::remove\+If\+Exists (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



remove a file, checking for its existance first 


\begin{DoxyParams}{Parameters}
{\em filename} & to remove \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_aac769ce6e901f32820cd7dc3fef989fa}\label{classomexmeta_1_1OmexMetaUtils_aac769ce6e901f32820cd7dc3fef989fa}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!splitStringBy@{splitStringBy}}
\index{splitStringBy@{splitStringBy}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{splitStringBy()}{splitStringBy()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::string $>$ omexmeta\+::\+Omex\+Meta\+Utils\+::split\+String\+By (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{char}]{delimiter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



split a string into a vector of strings by 


\begin{DoxyParams}{Parameters}
{\em delimiter} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a66d58e0ebcbee1857b23ead70c87de7f}\label{classomexmeta_1_1OmexMetaUtils_a66d58e0ebcbee1857b23ead70c87de7f}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!startsWith@{startsWith}}
\index{startsWith@{startsWith}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{startsWith()}{startsWith()}}
{\footnotesize\ttfamily bool omexmeta\+::\+Omex\+Meta\+Utils\+::starts\+With (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{full\+\_\+string,  }\item[{const std\+::string \&}]{start }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



returns true when 


\begin{DoxyParams}{Parameters}
{\em full\+\_\+string} & starts with the substring\\
\hline
{\em start} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_a6f8e406b8798bd2f1f0ae0d1bd07ed2b}\label{classomexmeta_1_1OmexMetaUtils_a6f8e406b8798bd2f1f0ae0d1bd07ed2b}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!stringInVector@{stringInVector}}
\index{stringInVector@{stringInVector}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{stringInVector()}{stringInVector()}}
{\footnotesize\ttfamily bool omexmeta\+::\+Omex\+Meta\+Utils\+::string\+In\+Vector (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::string $>$}]{vec,  }\item[{const std\+::string \&}]{string }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



returns true when 

return true if


\begin{DoxyParams}{Parameters}
{\em string} & is in\\
\hline
{\em vec} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1OmexMetaUtils_aca2230ca99338b9dc0fc7d296b0c553b}\label{classomexmeta_1_1OmexMetaUtils_aca2230ca99338b9dc0fc7d296b0c553b}} 
\index{omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}!stringReplace@{stringReplace}}
\index{stringReplace@{stringReplace}!omexmeta::OmexMetaUtils@{omexmeta::OmexMetaUtils}}
\doxysubsubsection{\texorpdfstring{stringReplace()}{stringReplace()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Omex\+Meta\+Utils\+::string\+Replace (\begin{DoxyParamCaption}\item[{std\+::string}]{str,  }\item[{const std\+::string \&}]{string\+\_\+to\+\_\+replace,  }\item[{const std\+::string \&}]{replacement }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



replace a part of a string 


\begin{DoxyParams}{Parameters}
{\em string\+\_\+to\+\_\+replace} & from a main\\
\hline
{\em string} & with a replacement string\\
\hline
{\em replacement} & \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/omexmeta/include/omexmeta/Omex\+Meta\+Utils.\+h\item 
src/omexmeta/Omex\+Meta\+Utils.\+cpp\end{DoxyCompactItemize}
